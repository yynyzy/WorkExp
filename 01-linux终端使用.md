# Linux 学习

# linux下安装：
```
sudo apt-get install terminator
```


# 1.常用快捷键
## 在同一个标签内的
```
Ctrl+Shift+O                    //水平分割终端
Ctrl+Shift+E                    //垂直分割终端
Ctrl+Shift+Right                //在垂直分割的终端中将分割条向右移动
Ctrl+Shift+Left                 //在垂直分割的终端中将分割条向左移动
Ctrl+Shift+Up                   //在水平分割的终端中将分割条向上移动
Ctrl+Shift+Down                 //在水平分割的终端中将分割条向下移动
Ctrl+Shift+F                    //搜索
Ctrl+Shift+W                    //关闭当前终端
Ctrl+Shift+Q                    //退出当前窗口，当前窗口的所有终端都将被关闭
Ctrl+Shift+Z                    //最大化显示当前终端并使字体放大
```

## 有关各个标签之间的操作
```
F11                             //全屏开关
Ctrl+Shift+T                    //打开一个新的标签
Ctrl+PageDown                   //移动到下一个标签
Ctrl+PageUp                     //移动到上一个标签
Ctrl+Shift+PageDown             //将当前标签与其后一个标签交换位置
Ctrl+Shift+PageUp               //将当前标签与其前一个标签交换位置
Ctrl+Shift+R                    //重置终端状态
Ctrl+Shift+G                    //重置终端状态并clear屏幕
Super+g                         //绑定所有的终端，以便向一个输入能够输入到所有的终端
Super+Shift+G                   //解除绑定
Super+t                         //绑定当前标签的所有终端，向一个终端输入的内容会自动输入到其他终端
Super+Shift+T                   //解除绑定
Ctrl+Shift+I                    //打开一个窗口，新窗口与原来的窗口使用同一个进程
```

# 2.什么是 shell
shell 就是一个程序，它接受从键盘输入的命令， 然后把命令传递给操作系统去执行。几乎所有的 Linux 发行版都提供一个名为 bash 的 来自 GNU 项目的 shell 程序。
当使用图形用户界面时，我们需要另一个和 shell 交互的叫做终端仿真器的程序。称为 “terminal”。 有 许多终端仿真器可供 Linux 使用，但基本上它们都为了让我们能访问 shell。

·如果提示符的最后一个字符是“#”, 而不是“$”, 那么这个终端会话就有超级用户权限。  
·如果你按下鼠标左键，沿着文本拖动鼠标（或者双击一个单词）高亮了一些文本， 那么这些高亮的文本就被拷贝到了一个由 X 管理的缓冲区里面。然后按下鼠标中键， 这些文本就被粘贴到光标所在的位置。  

## 一些简单的终端命令
- 显示日期与时间
 ```
 date           
 ```
- 它默认显示当前月份的日历
 ```
 cal            
 ```
- 查看磁盘剩余空间的数量
 ```
 df
 ```
- 显示空闲内存的数量
 ```
 free
 ```
- 通过关闭终端仿真器窗口，或者是在 shell 提示符下输入 exit 命令来终止一个终端会话
 ```
 exit            
 ```

## tips
 即使终端仿真器没有运行，在后台仍然有几个终端会话运行着。它们叫做虚拟终端 或者是虚拟控制台。在大多数 Linux 发行版中，这些终端会话都可以通过按下 Ctrl-Alt-F1 到 Ctrl-Alt-F6 访问。当一个会话被访问的时候，\它会显示登录提示框，我们需要输入用户名和密码。要从一个虚拟控制台转换到另一个， 按下 Alt 和 F1-F6(中的一个)。返回图形桌面，按下 Ctrl-Alt-F1 或者 Alt-F7。


# 3.文件系统中跳转
## 文件系统树
类似于 Windows，一个“类 Unix” 的操作系统，比如说 Linux，以分层目录结构来组织所有文件。 这就意味着所有文件组成了一棵树型目录（有时候在其它系统中叫做文件夹）， 这个目录树可能包含文件和其它的目录。文件系统中的第一级目录称为根目录。 根目录包含文件和子目录，子目录包含更多的文件和子目录，依此类推。  
**注意!**(类 Unix 系统)不像 Windows ，每个存储设备都有一个独自的文件系统树。类 Unix 操作系统， 比如 Linux，总是只有一个单一的文件系统树，不管有多少个磁盘或者存储设备连接到计算机上。 根据负责维护系统安全的系统管理员的兴致，存储设备连接到（或着更精确些，是挂载到）目录树的各个节点上。

— 打印出当前工作目录名
```
pwd
```
— 更改目录  
路径名可通过两种方式来指定:  
绝对路径:  
    -绝对路径开始于根目录，紧跟着目录树的一个个分支，一直到达所期望的目录或文件。  
相对路径:  
    -符号 “.” 指的是工作目录，”..” 指的是工作目录的父目录。
```
cd
```
— 列出一个目录包含的文件及子目录
```
ls
```

## cd 快捷键
快捷键	                            运行结果
```  
cd	                        更改工作目录到你的家目录。
```
```  
cd -	                    更改工作目录到先前的工作目录。
```
```  
cd ~user_name	            更改工作目录到用户家目录。例如, cd ~bob 会更改工作目录到用户“bob”的家目录。 
```

## 关于文件名的重要规则
以 “.” 字符开头的文件名是隐藏文件。这仅表示，ls 命令不能列出它们， 用 ls -a 命令就可以了。当你创建帐号后，几个配置帐号的隐藏文件被放置在 你的家目录下。稍后，我们会仔细研究一些隐藏文件，来定制你的系统环境。 另外，一些应用程序也会把它们的配置文件以隐藏文件的形式放在你的家目录下面。  

文件名和命令名是大小写敏感的。文件名 “File1” 和 “file1” 是指两个不同的文件名。  

Linux 没有“文件扩展名”的概念，不像其它一些系统。可以用你喜欢的任何名字 来给文件起名。文件内容或用途由其它方法来决定。虽然类 Unix 的操作系统， 不用文件扩展名来决定文件的内容或用途，但是有些应用程序会。  

虽然 Linux 支持长文件名，文件名可能包含空格，标点符号，但标点符号仅限 使用 “.”，“－”，下划线。最重要的是，不要在文件名中使用空格。如果你想表示词与词间的空格，用下划线字符来代替。将来你就会明白这样做的好处。 

# 4.探究操作系统
## — 列出目录内容
```
ls  
```
·ls 命令选项
```  
-a	--all	列出所有文件，甚至包括文件名以圆点开头的默认会被隐藏的隐藏文件。  
``` 
``` 
-d	--directory	通常，如果指定了目录名，ls 命令会列出这个目录中的内容，而不是目录本身。 把这个选项与 -l 选项结合使用，可以看到所指定目录的详细信息，而不是目录中的内容。  
``` 
``` 
-F	--classify	这个选项会在每个所列出的名字后面加上一个指示符。例如，如果名字是 目录名，则会加上一个'/'字符。  
``` 
``` 
-h	--human-readable	当以长格式列出时，以人们可读的格式，而不是以字节数来显示文件的大小。  
``` 
``` 
-l		以长格式显示结果。  
``` 
``` 
-r	--reverse	以相反的顺序来显示结果。通常，ls 命令的输出结果按照字母升序排列。  
``` 
``` 
-S		命令输出结果按照文件大小来排序。  
``` 
``` 
-t		按照修改时间来排序。  
``` 
### ls 长格式列表的字段
|  字段        | 含义  |
|  ----       | ----  |
| -rw-r--r--  | 对于文件的访问权限。第一个字符指明文件类型。在不同类型之间， 开头的“－”说明是一个普通文件，“d”表明是一个目录。其后三个字符是文件所有者的 访问权限，再其后的三个字符是文件所属组中成员的访问权限，最后三个字符是其他所 有人的访问权限。这个字段的完整含义将在第十章讨论。 |
| 1	  | 文件的硬链接数目。参考随后讨论的关于链接的内容。 |
| root  | 文件所有者的用户名。 |
| 32059	  |以字节数表示的文件大小。 |
| 2007-04-03  11:05  | 上次修改文件的时间和日期。 |
| oo-cd-cover.odf | 文件名。 |


## — 确定文件类型
```
file filename
```

## — 浏览文件内容
```
less filename
```
例如，要查看一个定义了系统中全部用户身份的文件，输入以下命令：
```
less /etc/passwd
```
如果文件内容多于一页，那么我们可以上下滚动文件。按下“q”键， 退出 less 程序。  
less 程序是早期 Unix 程序 more 的改进版。less 属于”页面调度器”类程序，这些程序允许以逐页方式轻松浏览长文本文档。 more 程序只能向前翻页，而 less 程序允许前后翻页，此外还有很多其它的特性。 


## Linux 系统中的目录
|  目录   | 评论  |
|  ----  | ----  |
| /  | 根目录，万物起源。|
| /bin  | 包含系统启动和运行所必须的二进制程序。|
| /boot | 包含 Linux 内核、初始 RAM 磁盘映像（用于启动时所需的驱动）和 启动加载程序。|
| /dev  | 这是一个包含设备结点的特殊目录。“一切都是文件”，也适用于设备。 在这个目录里，内核维护着所有设备的列表。|
| /etc  | 这个目录包含所有系统层面的配置文件。它也包含一系列的 shell 脚本， 在系统启动时，这些脚本会开启每个系统服务。这个目录中的任何文件应该是可读的文本文件。|
| /home | 	在通常的配置环境下，系统会在 /home 下，给每个用户分配一个目录。普通用户只能 在自己的目录下写文件。这个限制保护系统免受错误的用户活动破坏。|
| /lib  | 包含核心系统程序所使用的共享库文件。这些文件与 Windows 中的动态链接库相似。|
| /lost+found | 每个使用 Linux 文件系统的格式化分区或设备，例如 ext3文件系统， 都会有这个目录。当部分恢复一个损坏的文件系统时，会用到这个目录。这个目录应该是空的，除非文件系统 真正的损坏了。|
| /media  | 在现在的 Linux 系统中，/media 目录会包含可移动介质的挂载点， 例如 USB 驱动器，CD-ROMs 等等。这些介质连接到计算机之后，会自动地挂载到这个目录结点下。|
| /mnt | 在早些的 Linux 系统中，/mnt 目录包含可移动介质的挂载点。|
| /opt | 这个/opt 目录被用来安装“可选的”软件。这个主要用来存储可能 安装在系统中的商业软件产品。|
| /proc  | 这个/proc 目录很特殊。从存储在硬盘上的文件的意义上说，它不是真正的文件系统。是一个由 Linux 内核维护的虚拟文件系统。它所包含的文件是内核的窥视孔。这些文件是可读的。|
| /root  | root 帐户的家目录。|
| /sbin  | 包含系统启动和运行所必须的二进制程序。|
| /tmp | 这个/tmp 目录，是用来存储由各种程序创建的临时文件的地方。系统每次 重新启动时，都会清空这个目录。|
| /usr  | 在 Linux 系统中，/usr 目录可能是最大的一个。它包含普通用户所需要的所有程序和文件。|
| /usr/bin | /usr/bin 目录包含系统安装的可执行程序。通常，这个目录会包含许多程序。|
| /usr/lib | 包含由/usr/bin 目录中的程序所用的共享库。|
| /usr/local  | 这个/usr/local 目录，是非系统发行版自带程序的安装目录。 通常，由源码编译的程序会安装在/usr/local/bin 目录下。新安装的 Linux 系统中会存在这个目录， 并且在管理员安装程序之前，这个目录是空的。|
| /usr/sbin  | 包含许多系统管理程序。|
| /usr/share  | /usr/share 目录包含许多由 /usr/bin 目录中的程序使用的共享数据。 其中包括像默认的配置文件、图标、桌面背景、音频文件等等。|
| /usr/share/doc  | 大多数安装在系统中的软件包会包含一些文档。在/usr/share/doc 目录下， 我们可以找到按照软件包分类的文档。|
| /var  | 除了/tmp 和/home 目录之外，相对来说，目前我们看到的目录是静态的，这是说， 它们的内容不会改变。/var 目录存放的是动态文件。各种数据库，假脱机文件， 用户邮件等等，都位于在这里。|
| /var/log | 这个/var/log 目录包含日志文件、各种系统活动的记录。这些文件非常重要，并且 应该时时监测它们。其中最重要的一个文件是 /var/log/messages。注意，为了系统安全，在一些系统中， 你必须是超级用户才能查看这些日志文件。|



# 5.操作文件和目录

## 通配符
|通配符	|意义|
|----|----|
|*	|匹配任意多个字符（包括零个或一个）|
|?	|匹配任意一个字符（不包括零个）|
|[characters]	|匹配任意一个属于字符集（characters）中的字符|
|[!characters]	|匹配任意一个不是字符集中的字符|
|[[:class:]]	|匹配任意一个属于指定字符类中的字符|

## 普遍使用的字符类
|字符类|	意义|
|----|----|
|[:alnum:] |	匹配任意一个字母或数字|
|[:alpha:] |	匹配任意一个字母|
|[:digit:] |	匹配任意一个数字|
|[:lower:] |	匹配任意一个小写字母|
|[:upper:] |	匹配任意一个大写字母|


## 通配符范例
|模式|	匹配对象|
|----|----|
|*	                       |  所有文件|
|g*	                       |  文件名以“g”开头的文件|
|b*.txt	                   | 以"b"开头，中间有零个或任意多个字符，并以".txt"结尾的文件|
|Data???	               |  以“Data”开头，其后紧接着3个字符的文件|
|[abc]*	                   | 文件名以"a","b",或"c"开头的文件|
|BACKUP.[0-9][0-9][0-9]   |	以"BACKUP."开头，并紧接着3个数字的文件|
|[[:upper:]]*             |	以大写字母开头的文件|
|[![:digit:]]*          	|不以数字开头的文件|
|*[[:lower:]123]	       |     文件名以小写字母结尾，或以 “1”，“2”，或 “3” 结尾的文件|


## 1.mkdir - 创建目录
```
mkdir directory...
```
注意: 在描述一个命令时（如上所示），当有三个圆点跟在一个命令的参数后面， 这意味着那个参数可以跟多个，就像这样：
```
mkdir dir1 dir2 dir3
```

## 2.cp - 复制文件和目录
cp 命令，复制文件或者目录。它有两种使用方法：
1.复制单个文件或目录”item1”到文件或目录”item2”，和：
```
cp item1 item2
```
2.复制多个项目（文件或目录）到一个目录下。
```
cp item... directory
```

### cp 选项
|选项	|意义|
|----|----|
|-a, --archive	   | 复制文件和目录，以及它们的属性，包括拥有者和所有权。 通常情况下，文件拷贝具有执行拷贝操作的用户的默认属性。|
|-i, --interactive|	在覆盖已存在文件之前，提示用户确认。如果这个选项不指定， cp 命令会默认覆盖文件。|
|-r, --recursive	|递归地复制目录及目录中的内容。当复制目录时， 需要这个选项（或者 -a 选项）。|
|-u, --update	  |当把文件从一个目录复制到另一个目录时，仅复制 目标目录中不存在的文件，或者是文件内容新于目标目录中已经存在文件的内容的文件。|
|-v, --verbose	  |显示详实的命令操作信息|


### cp 实例
|命令	                |运行结果|
|----|----|
|cp file1 file2	        |复制文件 file1 内容到文件 file2。如果 file2 已经存在， file2 的内容会被 file1 的内容覆盖。如果 file2 不存在，则会创建 file2。|
|cp -i file1 file2	    |这条命令和上面的命令一样，除了如果文件 file2 存在的话，在文件 file2 被覆盖之前， 会提示用户确认信息。|
|cp file1 file2 dir1    |	复制文件 file1 和文件 file2 到目录 dir1。目录 dir1 必须存在。|
|cp dir1/* dir2	        |使用一个通配符，在目录 dir1 中的所有文件都被复制到目录 dir2 中。 dir2 必须已经存在。|
|cp -r dir1 dir2	    |复制目录 dir1 中的内容到目录 dir2。如果目录 dir2 不存在， 创建目录 dir2，操作完成后，目录 dir2 中的内容和 dir1 中的一样。 如果目录 dir2 存在，则目录 dir1 (和目录中的内容)将会被复制到 dir2 中。|


## 3.mv - 移动和重命名文件

mv 命令可以执行文件移动和文件命名任务。任何一种情况下，完成操作之后，原来的文件名不再存在。  
把文件或目录 “item1” 移动或重命名为 “item2”, 或者：
```
mv item1 item2
```
把一个或多个条目从一个目录移动到另一个目录中。
```
mv item... directory
```

### mv 选项
|选项	            |意义|
|----|----|
|-i --interactive	|在覆盖一个已经存在的文件之前，提示用户确认信息。 如果不指定这个选项，mv 命令会默认覆盖文件内容。|
|-u --update	    |当把文件从一个目录移动另一个目录时，只是移动不存在的文件， 或者文件内容新于目标目录相对应文件的内容的文件。|
|-v --verbose	    |当操作 mv 命令时，显示详实的操作信息。|

### mv 实例
|命令	                |运行结果|
|----|----|
|mv file1 file2	    |移动 file1 到 file2。如果 file2 存在，它的内容会被 file1 的内容覆盖。 如果 file2 不存在，则创建 file2。 这两种情况下，file1 都不再存在。|
|mv -i file1 file2	|除了如果 file2 存在的话，在 file2 被覆盖之前，用户会得到 提示信息外，这个和上面的选项一样。|
|mv file1 file2 dir1|	移动 file1 和 file2 到目录 dir1 中。dir1 必须已经存在。|
|mv dir1 dir2	    |如果目录 dir2 不存在，创建目录 dir2，并且移动目录 dir1 的内容到 目录 dir2 中，同时删除目录 dir1。如果目录 dir2 存在，移动目录 dir1（及它的内容）到目录 dir2。|


## 4.rm - 删除文件和目录
rm 命令用来删除文件和目录：
```
rm item...
```
“item”代表一个或多个文件或目录。

###  rm 选项
|选项	            |意义|
|----|----|
|-i, --interactive	|在删除已存在的文件前，提示用户确认信息。 如果不指定这个选项，rm 会默默地删除文件|
|-r, --recursive	|递归地删除文件，这意味着，如果要删除一个目录，而此目录 又包含子目录，那么子目录也会被删除。要删除一个目录，必须指定这个选项。|
|-f, --force	    |忽视不存在的文件，不显示提示信息。这选项覆盖了“--interactive”选项。|
|-v, --verbose  	|在执行 rm 命令时，显示翔实的操作信息。|

### rm 实例
|命令	                |运行结果|
|----|----|
|rm file1	        |默默地删除文件 |
|rm -i file1	    |除了在删除文件之前，提示用户确认信息之外，和上面的命令作用一样。|
|rm -r file1 dir1	|删除文件 file1, 目录 dir1，及 dir1 中的内容。|
|rm -rf file1 dir1	|同上，除了如果文件 file1，或目录 dir1 不存在的话，rm 仍会继续执行。|


## 5.ln — 创建链接
ln 命令既可创建硬链接，也可以创建符号链接。可以用两者中的任意一种形式来使用它：  
创建硬链接：  
```
ln file link
```
创建符号链接，”item” 可以是一个文件或是一个目录：  
```
ln -s item link
```


### 硬链接
与更加现代的符号链接相比，硬链接是最初 Unix 创建链接的方式。每个文件默认会有一个硬链接， 这个硬链接给予文件名字。我们每创建一个硬链接，就为一个文件创建了一个额外的目录项。硬链接有两个重要局限性：  
1.一个硬链接不能关联它所在文件系统之外的文件。这是说一个链接不能关联 与链接本身不在同一个磁盘分区上的文件。  
2.一个硬链接不能关联一个目录。  
一个硬链接和文件本身表面上看不出什么区别。它跟符号链接很不一样，当你列出一个包含硬链接的目录内容时，你会看不到有什么特殊说明来表示这是一个链接。当一个硬链接被删除时，这个链接 被删除，但是文件本身的内容仍然存在（这是说，它所占的磁盘空间不会被释放），直到所有关联这个文件的链接都删除掉。

### 符号链接
在我们到处查看时，我们可能会看到一个目录，列出像这样的一条信息：
```
lrwxrwxrwx 1 root root 11 2007-08-11 07:34 libc.so.6 -> libc-2.6.so
```
注意看，为何这条信息第一个字符是“l”，并且有两个文件名呢？ 这是一个特殊文件，叫做符号链接（也称为软链接或者 symlink ）。 在大多数“类 Unix” 系统中， 有可能一个文件被多个文件名所指向。这个特性实际中真的很有用。  

创建符号链接是为了克服硬链接的局限性。符号链接生效，是通过创建一个 特殊类型的文件，这个文件包含一个关联文件或目录的文本指针。  

一个符号链接指向一个文件，而且这个符号链接本身与其它的符号链接几乎没有区别。 例如，如果你往一个符号链接里面写入东西，那么相关联的文件也被写入。然而， 当你删除一个符号链接时，只有这个链接被删除，而不是文件自身。如果先于符号链接 删除文件，这个链接仍然存在，但是不指向任何东西。在这种情况下，这个链接被称为 坏链接。在许多实现中，ls 命令会以不同的颜色展示坏链接，比如说红色，来显示它们 的存在。  


# 6.使用命令
##  到底什么是命令？
命令可以是下面四种形式之一：  
1.一个可执行程序，就像我们所看到的位于目录/usr/bin 中的文件一样。 这一类程序可以是用诸如 C 和 C++ 语言写成的程序然后编译得到的二进制文件, 也可以是由诸如 shell，perl，python，ruby 等等脚本语言写成的程序。  

2.一个内建于 shell 自身的命令。bash 支持若干命令，内部叫做 shell 内部命令 (builtins)。例如，cd 命令，就是一个 shell 内部命令。  

3.一个 shell 函数。这些是小规模的 shell 脚本，它们混合到环境变量中。 在后续的章节里，我们将讨论配置环境变量以及书写 shell 函数。但是现在， 仅仅意识到它们的存在就可以了。  

4.一个命令别名。我们可以定义自己的命令，建立在其它命令之上。  

## 识别命令
准确地知道正在使用的四种命令中的哪一种通常很有用 Linux 提供了几种查找方法。

### type － 显示命令的类型
type 命令是 shell 内部命令，它会显示命令的类型，给出一个特定的命令名（做为参数）。 它像这样工作：
```
type command
```
command 是你要检测的命令名。这里有些例子：
```
$ type type
type is a shell builtins

$ type ls
ls is aliased to `ls --color=tty`

$ type cp
cp is /bin/cp
```

### which － 显示一个可执行程序的位置
有时候在一个操作系统中，不只安装了可执行程序的一个版本。虽然在桌面系统中这并不普遍， 但在大型服务器中却很平常。为了确定所给定的执行程序的准确位置，使用 which 命令：
```
$ which ls
/bin/ls
```
which 命令只对可执行程序有效，不包括内建命令和命令别名。 当我们试着使用 shell 内建命令时，例如，cd 命令，我们或者得不到回应，或者是个错误信息：
```
$ which cd
/usr/bin/which: no cd in
(/opt/jre1.6.0_03/bin:/usr/lib/qt-3.3/bin:/usr/kerberos/bin:/opt/jre1.6.0_03/bin:/usr/lib/ccache:/usr/local/bin:/usr/bin:/bin:/home/me/bin)which is a fancy way of saying “command not found.”
```
这些信息真正的意思就是“命令没有找到”。

## 得到命令文档
### help － 得到 shell 内建命令的帮助文档
bash 有一个内建的 help 命令，可查找每一个 shell 内建命令的文档。输入“help”，接着是 shell 内部命令名。例如：
```
$ help cd
cd: cd [-L|-P] [dir]
Change ...
```
注意：出现在命令语法说明中的方括号证的内容是可选的项目。一个竖杠字符 表示互斥选项。在上面 cd 命令的例子中：  
这种表示法说明，cd 命令可以跟一个“-L”选项“-P”选项其中之一或者什么都不跟，“dir”也是可选参数。  

### --help - 显示用法信息
许多可执行程序支持一个 --help 选项，这个选项是显示命令所支持的语法和选项说明。例如：
```
$ mkdir --help
Usage: mkdir [OPTION] DIRECTORY...
Create ...
```
一些程序不支持 --help 选项，但不管怎样试一下。通常输出的错误提示也同样能揭示命令的用法信息。  

### man － 显示用户手册
许多希望被命令行使用的可执行程序，提供了一个正式的文档，叫做手册或手册页(man page)。一个特殊的叫做 man 的分页程序，可用来浏览他们。它是这样使用的：
```
man program
```
“program”是要浏览的命令名。

### apropos － 显示适合的命令
我们也可以搜索全部参考手册来找到自己需要的命令，这个方法虽然很粗糙但有时很有用。 下面是一个以”floppy”为关键词来搜索参考手册的例子：
```
$ apropos floppy
...
```

输出结果每行的第一个字段是手册页的名字，第二个字段展示章节。注意，man 命令加上”-k”选项， 和 apropos 完成一样的功能。

### whatis － 显示非常简洁的命令说明
whatis 程序显示匹配特定关键字的手册页的名字和一行命令说明

### info － 显示程序 Info 条目
GNU 项目提供了一个命令程序手册页的替代物，称为”info”。info 内容可通过 info 阅读器 程序读取。info 页是超级链接形式的，和网页很相似。  
输入”info”，接着输入程序名称，启动 info。

## 用别名（alias）创建你自己的命令
通过 alias 命令 把这一串命令转变为一个命令。为新命令构想一个名字。 比方说”test”。在使用”test”之前，最好先查明”test”命令名是否已经存在于系统中。 可以使用 type 命令.
### 创建命令别名：
```
$ alias foo='cd /usr; ls; cd -'
```

注意命令结构：
```
alias name='string'
```
在命令”alias”之后，输入“name”，紧接着（没有空格）是一个等号，等号之后是 一串用引号引起的字符串，字符串的内容要赋值给 name。

### 删除别名，使用 unalias 命令，像这样：
```
$ unalias foo
```

# 7.重定向
```
cat － 连接文件

sort － 排序文本行

uniq － 报道或省略重复行

grep － 打印匹配行

wc － 打印文件中换行符，字，和字节个数

head － 输出文件第一部分

tail - 输出文件最后一部分

tee - 从标准输入读取数据，并同时写到标准输出和文件
```

## 标准输入、标准输出和标准错误输出
我们用到的许多程序都会产生某种输出。这种输出，经常由两种类型组成。  
第一，程序运行结果；这是说，程序要完成的功能。  
第二，我们得到状态和错误信息， 这些告诉我们程序进展。如果我们观察一个命令，例如 ls，会看到它的运行结果和错误信息 显示在屏幕上。  

与 Unix 主题“任何东西都是一个文件”保持一致，像 ls这样的程序实际上把他们的运行结果 输送到一个叫做标准输出的特殊文件（经常用 stdout 表示），而它们的状态信息则送到另一个 叫做标准错误输出的文件（stderr）。默认情况下，标准输出和标准错误输出都连接到屏幕，而不是 保存到磁盘文件。除此之外，许多程序从一个叫做标准输入（stdin）的设备得到输入，默认情况下， 标准输入连接到键盘。  

I/O 重定向允许我们更改输出地点和输入来源。一般来说，输入来自键盘，输出送到屏幕， 但是通过 I/O 重定向，我们可以做出改变

## 标准输出重定向
I/O 重定向允许我们来重定义标准输出的地点。我们使用 “>” 重定向符后接文件名将标准输出重定向到除屏幕以外的另一个文件。为什么我们要这样做呢？因为有时候把一个命令的运行结果存储到 一个文件很有用处。例如，我们可以告诉 shell 把 ls 命令的运行结果输送到文件 ls-output.txt 中去，由文件代替屏幕。
```
$ ls -l /usr/bin > ls-output.txt
```
这里，我们创建了一个长长的目录 /usr/bin 列表，并且输送程序运行结果到文件 ls-output.txt 中。  

现在，重复我们的重定向测试，但这次有改动。我们把目录换成一个不存在的目录。  
```
$ ls -l /bin/usr > ls-output.txt
ls: cannot access /bin/usr: No such file or directory
```
我们收到一个错误信息。这讲得通，因为我们指定了一个不存在的目录 /bin/usr ， 但是为什么这条错误信息显示在屏幕上而不是被重定向到文件 ls-output.txt？答案是，ls 程序不把它的错误信息输送到标准输出。像许多写得正规的 Unix 程序，ls 会把 错误信息送到标准错误输出。因为我们只是重定向了标准输出，而没有重定向标准错误输出， 所以错误信息被送到屏幕。马上，我们将知道怎样重定向标准错误输出，但是首先看一下 我们的输出文件发生了什么事情。
```
$ ls -l ls-output.txt
-rw-rw-r-- 1 me   me    0 2008-02-01 15:08 ls-output.txt
```
当我们使用 “>” 重定向符来重定向输出结果时，目标文件总是从开头被重写。 因为我们 ls 命令没有产生运行结果，只有错误信息，重定向操作开始重写文件，然后由于错误而停止，导致文件内容清空。事实上，如果我们需要清空一个文件内容（或者创建一个新的空文件），可以使用这样的技巧：
```
$ > ls-output.txt
```
简单地使用重定向符，没有命令在它之前，这会清空一个已存在文件的内容或是 创建一个新的空文件。  

所以，怎样才能把重定向结果追加到文件内容后面，而不是从开头重写文件？为了这个目的， 我们使用”>>“重定向符，像这样：
```
$ ls -l /usr/bin >> ls-output.txt
```
使用”>>“操作符，将导致输出结果添加到文件内容之后。如果文件不存在，文件会 被创建，就如使用了”>”操作符。来试一下：
```
$ ls -l /usr/bin >> ls-output.txt
$ ls -l /usr/bin >> ls-output.txt
$ ls -l /usr/bin >> ls-output.txt
$ ls -l ls-output.txt
-rw-rw-r-- 1 me   me    503634 2008-02-01 15:45 ls-output.txt
```
我们重复执行命令三次，导致输出文件大小是原来的三倍。

## 标准错误输出重定向
标准错误输出重定向没有专用的重定向操作符。为了重定向标准错误输出，我们必须用到其文件描述符。一个程序的输出会流入到几个带编号的文件中。这些文件的前 三个称作标准输入、标准输出和标准错误输出，shell 内部分别将其称为文件描述符0、1和2。shell 使用文件描述符提供 了一种表示法来重定向文件。因为标准错误输出和文件描述符2一样，我们用这种表示法来重定向标准错误输出：
```
$ ls -l /bin/usr 2> ls-error.txt
```
文件描述符”2”，紧挨着放在重定向操作符之前，来执行重定向标准错误输出到文件 ls-error.txt 任务。

## 重定向标准输出和错误到同一个文件
有时我们希望将一个命令的所有输出保存到一个文件。为此，我们 必须同时重定向标准输出和标准错误输出。有两种方法来完成任务。第一个是传统的方法， 在旧版本 shell 中也有效：
```
$ ls -l /bin/usr > ls-output.txt 2>&1
```
使用这种方法，我们完成两个重定向。首先重定向标准输出到文件 ls-output.txt，然后 重定向文件描述符2（标准错误输出）到文件描述符1（标准输出）使用表示法2>&1。  

注意重定向的顺序安排非常重要。标准错误输出的重定向必须总是出现在标准输出 重定向之后，要不然它不起作用。 

现在的 bash 版本提供了第二种方法，更精简合理的方法来执行这种联合的重定向。
```
$ ls -l /bin/usr &> ls-output.txt
```

## 处理不需要的输出
有时候“沉默是金”，我们不想要一个命令的输出结果，只想把它们扔掉。这种情况 尤其适用于错误和状态信息。具体做法是重定向输出结果到一个叫做”/dev/null”的特殊文件。这个文件是系统设备，叫做数字存储桶，它可以 接受输入，并且对输入不做任何处理。为了丢掉命令错误信息，我们这样做：
```
$ ls -l /bin/usr 2> /dev/null
```

## cat － 连接文件
cat 命令读取一个或多个文件，然后复制它们到标准输出，就像这样:
```
cat [file]
```
在大多数情况下，你可以认为 cat 命令相似于 DOS 中的 TYPE 命令。你可以使用 cat 来显示 文件而没有分页。  

cat 经常被用来显示简短的文本文件。因为 cat 可以 接受不只一个文件作为参数，所以它也可以用来把文件连接在一起。比方说我们下载了一个大型文件，这个文件被分离成多个部分（USENET 中的多媒体文件经常以这种方式分离），我们想把它们连起来。  
如果文件命名为：movie.mpeg.001 movie.mpeg.002 … movie.mpeg.099

我们能用这个命令把它们连接起来：
```
cat movie.mpeg.0* > movie.mpeg
```
因为通配符总是以有序的方式展开，所以这些参数会以正确顺序安排。  


如果我们输入不带参数的”cat”命令，会发生什么呢：
```
$ cat
```

如果 cat 没有给出任何参数，它会从标准输入读入数据，又因为标准输入默认情况下连接到键盘，它正在等待我们输入数据！试试这个：
```
$ cat
The quick brown fox jumped over the lazy dog.
```
下一步，输入 Ctrl-d（按住 Ctrl 键同时按下”d”），来告诉 cat，在标准输入中， 它已经到达文件末尾（EOF）：
```
$ cat
The quick brown fox jumped over the lazy dog.
The quick brown fox jumped over the lazy dog.
```

由于没有文件名参数，cat 复制标准输入到标准输出，所以我们看到文本行重复出现。 我们可以使用这种行为来创建简短的文本文件。比方说，我们想创建一个叫做”lazy_dog.txt” 的文件，这个文件包含例子中的文本。我们这样做：
```
[me@linuxbox ~]$ cat > lazy_dog.txt
The quick brown fox jumped over the lazy dog.
```
输入命令，其后输入要放入文件中的文本。记住，最后输入 Ctrl-d。通过使用这个命令，我们实现了世界上最低能的文字处理器！  

除了文件名参数，试着重定向标准输入：
```
$ cat < lazy_dog.txt
```

使用“<”重定向操作符，我们把标准输入源从键盘改到文件 lazy_dog.txt。我们看到结果 和传递单个文件名作为参数的执行结果一样。把这和传递一个文件名参数作比较，不是特别有意义， 但它是用来说明把一个文件作为标准输入源。

## 管道线
命令从标准输入读取数据并输送到标准输出的能力被一个称为管道线的 shell 功能所利用。 使用管道操作符”|”（竖杠），一个命令的标准输出可以通过管道送至另一个命令的标准输入：
```
command1 | command2
```

列如，我们用 less 来一页一页地显示任何命令的输出，命令把它的运行结果输送到标准输出：
```
$ ls -l /usr/bin | less
```

## 过滤器
管道线经常用来对数据完成复杂的操作。有可能会把几个命令放在一起组成一个管道线。 通常，以这种方式使用的命令被称为过滤器。过滤器接受输入，以某种方式改变它，然后 输出它。第一个我们想试验的过滤器是 sort。想象一下，我们想把目录/bin 和/usr/bin 中 的可执行程序都联合在一起，再把它们排序，然后浏览执行结果：
```
$ ls /bin /usr/bin | sort | less
```
因为我们指定了两个目录（/bin 和/usr/bin），ls 命令的输出结果由有序列表组成， 各自针对一个目录。通过在管道线中包含 sort，我们改变输出数据，从而产生一个有序列表。

## uniq - 报道或忽略重复行
uniq 命令经常和 sort 命令结合在一起使用。uniq 从标准输入或单个文件名参数接受数据有序列表，默认情况下，从数据列表中删除任何重复行。
```
$ ls /bin /usr/bin | sort | uniq | less
```

在这个例子中，我们使用 uniq 从 sort 命令的输出结果中，来删除任何重复行。如果我们想看到 重复内容，让 uniq 命令带上”-d”选项，就像这样：
```
$ ls /bin /usr/bin | sort | uniq -d | less
```

## wc － 打印行数、字数和字节数
wc（字数统计）命令是用来显示文件所包含的行数、字数和字节数。例如：
```
$ wc ls-output.txt
7902 64566 503634 ls-output.txt
```
在这个例子中，wc 打印出来三个数字：包含在文件 ls-output.txt 中的行数，单词数和字节数，正如我们先前的命令，如果 wc 不带命令行参数，它接受标准输入。”-l”选项限制命令输出只能报道行数。添加 wc 到管道线来统计数据，是个很便利的方法。查看我们的有序列表中程序个数， 我们可以这样做：
```
$ ls /bin /usr/bin | sort | uniq | wc -l
2728
```

## grep － 打印匹配行
grep 是个很强大的程序，用来找到文件中的匹配文本。这样使用 grep 命令：
```
grep pattern [file...]
```

当 grep 遇到一个文件中的匹配”模式”，它会打印出包含这个类型的行。grep 能够匹配的模式可以很复杂。  
比如说，我们想在我们的程序列表中，找到文件名中包含单词”zip”的所有文件。这样一个搜索， 可能让我们了解系统中的一些程序与文件压缩有关系。这样做：  
```
$ ls /bin /usr/bin | sort | uniq | grep zip
bunzip2
bzip2
gunzip
...
```


grep 有一些方便的选项：”-i”使得 grep 在执行搜索时忽略大小写（通常，搜索是大小写 敏感的），”-v”选项会告诉 grep 只打印不匹配的行。

## head / tail － 打印文件开头部分/结尾部分
有时候你不需要一个命令的所有输出。可能你只想要前几行或者后几行的输出内容。 head 命令打印文件的前十行，而 tail 命令打印文件的后十行。默认情况下，两个命令都打印十行文本，但是可以通过”-n”选项来调整命令打印的行数。
```
$ head -n 5 ls-output.txt
total 343496
...
```
```
$ tail -n 5 ls-output.txt
...
```

它们也能用在管道线中：
```
$ ls /usr/bin | tail -n 5
znew
...
```
tail 有一个选项允许你实时地浏览文件。当观察日志文件的进展时，这很有用，因为它们同时在被写入。在以下的例子里，我们要查看目录/var/log 里面的信息文件。在一些 Linux 发行版中，要求有超级用户权限才能阅读这些文件，因为文件 /var/log/messages 可能包含安全信息。
```
$ tail -f /var/log/messages
Feb 8 13:40:05 twin4 dhclient: DHCPACK from 192.168.1.1
....
```
使用”-f”选项，tail 命令继续监测这个文件，当新的内容添加到文件后，它们会立即出现在屏幕上。这会一直继续下去直到你输入 Ctrl-c。

## tee － 从 Stdin 读取数据，并同时输出到 Stdout 和文件
为了和我们的管道隐喻保持一致，Linux 提供了一个叫做 tee 的命令，这个命令制造了 一个”tee”（三通管件，做水管工人会对这个非常熟悉），安装到我们的管道上。tee 程序从标准输入读入数据，并且同时复制数据 到标准输出（允许数据继续随着管道线流动）和一个或多个文件。当在某个中间处理阶段来捕捉一个管道线的内容时，这很有帮助。这里，我们重复执行一个先前的例子，这次包含 tee 命令，在 grep 过滤管道线的内容之前，来捕捉整个目录列表到文件 ls.txt：
```
$ ls /usr/bin | tee ls.txt | grep zip
bunzip2
bzip2
....
```

# 8.从 shell 眼中看世界
```
echo － 显示一行文本
```

## (字符)展开
每当你输入一个命令并按下 enter 键，bash 会在执行你的命令之前对输入的字符完成几个步骤的处理。这背后的的过程叫做（字符）展开。通过展开，你输入的字符，在 shell 对它起作用之前，会展开成为别的字符。为了说明这一点，让我们看一看 echo 命令。echo 是一个 shell 内建命令，可以完成非常简单的任务。它将它的文本参数打印到标准输出中。
```
$ echo this is a test
this is a test
```
这个命令的作用相当简单明了。传递到 echo 命令的任一个参数都会在（屏幕上）显示出来。让我们试试另一个例子：
```
$ echo *
Desktop Documents ls-output.txt Music Pictures Public Templates Videos
```
为什么 echo 不打印”*“呢？如果你回忆起我们所学过的 关于通配符的内容，这个”*“字符意味着匹配文件名中的任意字符，但在原先的讨论中我们并不知道 shell 是怎样实现这个功能的。简单的答案就是 shell 在 echo 命令被执行前把”*“展开成了另外的东西（在这里，就是在当前工作目录下的文件名字）。 当回车键被按下时，shell 在命令被执行前在命令行上自动展开任何符合条件的字符， 所以 echo 命令的实际参数并不是”*“，而是它展开后的结果。

## 路径名展开
通配符所依赖的工作机制叫做路径名展开。
查看家目录之外的目录：
```
$ echo /usr/*/share
/usr/kerberos/share  /usr/local/share
```

隐藏文件路径名展开  

正如我们知道的，以圆点字符开头的文件名是隐藏文件。路径名展开也尊重这种行为。像这样的展开：
```
echo *
```
不会显示隐藏文件.  

直觉告诉我们，如果展开模式以一个圆点开头，我们就能够在展开中包含隐藏文件， 就像这样：
```
echo .*
```
它几乎要起作用了。然而，如果我们仔细检查一下输出结果，我们会看到名字”.” 和”..”也出现在结果中。由于它们是指当前工作目录和父目录，使用这种 模式可能会产生不正确的结果。   
为了在这种情况下正确地完成路径名展开，我们应该使用一个更精确的模式。 这个模式会正确地工作：
```
ls -d .[!.]?*
```
这种模式展开成所有以圆点开头，第二个字符不包含圆点，再包含至少一个字符， 并且这个字符之后紧接着任意多个字符的文件名。这个命令将正确列出大多数的隐藏文件 （但仍不能包含以多个圆点开头的文件名）。带有 -A 选项（“几乎所有”）的 ls 命令能够提供一份正确的隐藏文件清单：
```
ls -A	
```	

## 波浪线展开
当它用在一个单词的开头时，它会展开成指定用户的家目录名，如果没有指定用户名，则展开成当前用户的家目录：
```
$ echo ~
/home/me
```
如果有用户”foo”这个帐号，那么：
```
$ echo ~foo
/home/foo
```

## 算术表达式展开
shell 在展开中执行算数表达式。这允许我们把 shell 当作计算器来使用：
```
$ echo $((2 + 2))
4
```

算术表达式展开使用这种格式：
```
$((expression))
```
（以上括号中的）表达式是指算术表达式，它由数值和算术操作符组成。算术表达式只支持整数（全部是数字，不带小数点），但是能执行很多不同的操作。

## 花括号展开
可能最奇怪的展开是花括号展开。通过它，你可以从一个包含花括号的模式中 创建多个文本字符串。这是一个例子：
```
$ echo Front-{A,B,C}-Back
Front-A-Back Front-B-Back Front-C-Back
```

花括号展开模式可能包含一个开头部分叫做前言，一个结尾部分叫做附言。花括号表达式本身可 能包含一个由逗号分开的字符串列表，或者一个整数区间，或者单个的字符的区间。这种模式不能嵌入空白字符。这个例子中使用了一个整数区间：
```
$ echo Number_{1..5}
Number_1  Number_2  Number_3  Number_4  Number_5
```
倒序排列的字母区间：
```
$ echo {Z..A}
Z Y X W V U T S R Q P O N M L K J I H G F E D C B A
```
花括号展开可以嵌套：
```
$ echo a{A{1,2},B{3,4}}b
aA1b aA2b aB3b aB4b
```	

### 最常见的应用是，创建一系列的文件或目录列表。
例如， 如果我们是摄影师，有大量的相片。我们想把这些相片按年月先后组织起来。首先，我们要创建一系列以数值”年－月”形式命名的目录。通过这种方式，可以使目录名按照年代顺序排列。我们可以手动键入整个目录列表，但是工作量太大了，并且易于出错。反之，我们可以这样做：
```
$ mkdir Pics
$ cd Pics
$ mkdir {2007..2009}-0{1..9} {2007..2009}-{10..12}
$ ls
```	

## 参数展开
在这一章我们将会简单介绍参数展开，会在后续章节中进行详细讨论。这个特性在 shell 脚本中比直接在命令行中更有用。 它的许多功能和系统存储小块数据，并给每块数据命名的能力有关系。许多像这样的小块数据， 更恰当的称呼应该是变量，可供你方便地检查它们。例如，叫做”USER”的变量包含你的 用户名。可以这样做来调用参数，并查看 USER 中的内容，：
```
$ echo $USER
me
```

要查看有效的变量列表，可以试试这个：
```
[me@linuxbox ~]$ printenv | less
```
你可能注意到在其它展开类型中，如果你误输入一个字符串，展开就不会发生。这时 echo 命令只简单地显示误键入的字符串。但在参数展开中，如果你拼写错了一个变量名， 展开仍然会进行，只是展开的结果是一个空字符串：
```
$ echo $SUER
$
```

## 命令替换
命令替换允许我们把一个命令的输出作为另一个命令的一部分来使用：

我最喜欢用的一行命令是像这样的：
```
$ ls -l $(which cp)
-rwxr-xr-x 1 root root 71516 2007-12-05 08:58 /bin/cp
```

这里我们把 which cp 的执行结果作为一个参数传递给 ls 命令，因此可以在不知道 cp 命令 完整路径名的情况下得到它的文件属性列表。我们不只限于简单命令。  

使用整个管道线（只展示部分输出）：
```
$ file $(ls /usr/bin/* | grep zip)
/usr/bin/bunzip2:     symbolic link to `bzip2'
....
```
在这个例子中，管道线的输出结果成为 file 命令的参数列表。  

在旧版 shell 程序中，有另一种语法也支持命令替换，可与刚提到的语法轮换使用。 bash 也支持这种语法。它使用倒引号来代替美元符号和括号：
```
$ ls -l `which cp`
-rwxr-xr-x 1 root root 71516 2007-12-05 08:58 /bin/cp
```	

## 引用
```
$ echo this is a    test
this is a test
```
或者：
```
$ echo The total is $100.00
The total is 00.00
```
在第一个例子中，shell 利用单词分割删除掉 echo 命令的参数列表中多余的空格。在第二个例子中，参数展开把 $1 的值替换为一个空字符串，因为 1 是没有定义的变量。shell 提供了一种叫做引用的机制，来有选择地禁止不需要的展开。

### 双引号
看一下引用的第一种类型，双引号。如果你把文本放在双引号中， shell 使用的特殊字符，都失去它们的特殊含义，被当作普通字符来看待。有几个例外： $，\ (反斜杠），和 `（倒引号）。这意味着单词分割、路径名展开、波浪线展开和花括号展开都将失效，然而参数展开、算术展开和命令替换 仍然执行。使用双引号，我们可以处理包含空格的文件名。比方说 two words.txt 文件，如果我们试图在命令行中使用这个文件，单词分割机制会导致这个文件名被看作两个独自的参数，而不是所期望的单个参数：
```
$ ls -l two words.txt
ls: cannot access two: No such file or directory
ls: cannot access words.txt: No such file or directory
```
使用双引号，我们可以阻止单词分割，得到期望的结果；进一步，我们甚至可以修复破损的文件名。
```
$ ls -l "two words.txt"
-rw-rw-r-- 1 me   me   18 2008-02-20 13:03 two words.txt
$ mv "two words.txt" two_words.txt
```
记住，在双引号中，参数展开、算术表达式展开和命令替换仍然有效：
```
$ echo "$USER $((2+2)) $(cal)"
me 4    February 2008
Su Mo Tu We Th Fr Sa
....
```

### 引号
如果需要禁止所有的展开，我们要使用单引号。以下例子是无引用，双引号，和单引号的比较结果：
```
$ echo text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER
text /home/me/ls-output.txt a b foo 4 me
$ echo "text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER"
text ~/*.txt   {a,b} foo 4 me
$ echo 'text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER'
text ~/*.txt  {a,b} $(echo foo) $((2+2)) $USER
```
正如我们所看到的，随着引用程度加强，越来越多的展开被禁止。

## 转义字符
有时候我们只想引用单个字符。我们可以在字符之前加上一个反斜杠，在这里叫做转义字符。 经常在双引号中使用转义字符，来有选择地阻止展开。
```
$ echo "The balance for user $USER is: \$5.00"
The balance for user me is: $5.00
```
使用转义字符来消除文件名中一个字符的特殊含义，是很普遍的。例如，在文件名中可能使用 一些对于 shell 来说有特殊含义的字符。这些字符包括”$”, “!”, “ “等字符。在文件名中包含特殊字符，你可以这样做：
```
$ mv bad\&filename good_filename
```
为了允许反斜杠字符出现，输入”\“来转义。注意在单引号中，反斜杠失去它的特殊含义，它被看作普通字符。

## 反斜杠转义字符序列
反斜杠除了作为转义字符外，也可以构成一种表示法，来代表某种特殊字符，这些特殊字符叫做控制码。一些编码是众所周知的（制表符，退格符，换行符，和回车符）
|转义序列	|含义|
|----|----|
|\a	|响铃（”警告”－导致计算机嘟嘟响）|
|\b	|退格符|
|\n	|新的一行。在类 Unix 系统中，产生换行。|
|\r	|回车符|
|\t	|制表符|

echo 命令带上 ‘-e’ 选项，能够解释转义序列。你可以把转义序列放在 $' ' 里面。  
以下例子中，我们可以使用 sleep 命令创建一个简单的倒数计数器（ sleep 是一个简单的程序，它会等待指定的秒数，然后退出）：
```
sleep 10; echo -e "Time's up\a"
```
We could also do this: 我们也可以这样做：
```
sleep 10; echo "Time's up" $'\a'
```	

# 9.键盘高级操作技巧
```
clear - Clear the screen

history - Display the contents of the history list

clear － 清空屏幕

history － 显示历史列表内容

```
## 移动光标
### 光标移动命令
|按键	|行动|
|----|----|
|Ctrl-a|	移动光标到行首。|
|Ctrl-e|	移动光标到行尾。|
|Ctrl-f|	光标前移一个字符；和右箭头作用一样。|
|Ctrl-b|	光标后移一个字符；和左箭头作用一样。|
|Alt-f	|光标前移一个字。|
|Alt-b	|光标后移一个字。|
|Ctrl-l|	清空屏幕，移动光标到左上角。clear 命令完成同样的工作。
## 修改文本
### 文本编辑命令
|按键	|行动|
|----|----|
|Ctrl-d|	删除光标位置的字符。|
|Ctrl-t|	光标位置的字符和光标前面的字符互换位置。|
|Alt-t	|光标位置的字和其前面的字互换位置。|
|Alt-l	|把从光标位置到字尾的字符转换成小写字母。|
|Alt-u	|把从光标位置到字尾的字符转换成大写字母。|

## 剪切和粘贴文本

Readline 的文档使用术语 killing 和 yanking 来指我们平常所说的剪切和粘贴。 剪切下来的本文被存储在一个叫做剪切环(kill-ring)的缓冲区中。
### 剪切和粘贴命令
|按键	|行动|
|----|----|
|Ctrl-k	        |剪切从光标位置到行尾的文本。|
|Ctrl-u	        | 剪切从光标位置到行首的文本。|
|Alt-d	        |剪切从光标位置到词尾的文本。|
|Alt-Backspace	|剪切从光标位置到词头的文本。如果光标在一个单词的开头，剪切前一个单词。|
|Ctrl-y	        |把剪切环中的文本粘贴到光标位置。|

## 搜索历史命令
在任何时候，我们都可以浏览历史列表的内容，通过：
```
$ history | less
```
在默认情况下，bash 会存储你所输入的最后 500 个命令。比方说想在自己曾经用过的命令中，找出和/usr/bin这一目录相关的
```
$ history | grep /usr/bin
```

数字 “88” 是这个命令在历史列表中的行号。我们可以使用另一种叫做 历史命令展开的方式，来调用“88”所代表的这一行命令：
```
$ !88
```
bash 会把 “!88” 展开成为历史列表中88行的内容。  
bash 也具有增量搜索历史列表的能力。意思是在字符输入的同时，bash 会去搜索历史列表（直接出结果，并高亮匹配的第一个字），每多输入一个字符都会使搜索结果更接近目标。输入 Ctrl-r来启动增量搜索， 接着输入你要寻找的字。当你找到它以后，你可以敲入 Enter 来执行命令， 或者输入 Ctrl-j，从历史列表中复制这一行到当前命令行。再次输入 Ctrl-r，来找到下一个 匹配项（历史列表中向上移动）。输入 Ctrl-g 或者 Ctrl-c，退出搜索。

### 历史命令
|按键	|行动|
|----|----|
|Ctrl-p|	移动到上一个历史条目。类似于上箭头按键。|
|Ctrl-n|	移动到下一个历史条目。类似于下箭头按键。|
|Alt-<|	移动到历史列表开头。|
|Alt->|	移动到历史列表结尾，即当前命令行。|
|Ctrl-r|	反向增量搜索。从当前命令行开始，向上增量搜索。|
|Alt-p|	反向搜索，非增量搜索。（输入要查找的字符串，按下 Enter来执行搜索）。|
|Alt-n|	向前搜索，非增量。|
|Ctrl-o|	执行历史列表中的当前项，并移到下一个。如果你想要执行历史列表中一系列的命令，这很方便。|

## 历史命令展开
通过使用 “!” 字符，shell 为历史列表中的命令，提供了一个特殊的展开类型。我们已经知道一个感叹号 ，其后再加上一个数字，可以把来自历史列表中的命令插入到命令行中。这里还有一些其它的展开特性：
### 历史展开命令
|按键	|行动|
|----|----|
|!!	       | 重复最后一次执行的命令。可能按下上箭头按键和 enter 键更容易些。|
|!number	|    重复历史列表中第 number 行的命令。|
|!string	 |    重复最近历史列表中，以这个字符串开头的命令。|
|!?string	|重复最近历史列表中，包含这个字符串的命令。|

应该小心谨慎地使用 “!string” 和 “!?string” 格式，除非你完全确信历史列表条目的内容。


# 10.权限
```
id – Display user identity

id – 显示用户身份号

chmod – Change a file’s mode

chmod – 更改文件模式

umask – Set the default file permissions

umask – 设置默认的文件权限

su – Run a shell as another user

su – 以另一个用户的身份来运行 shell

sudo – Execute a command as another user

sudo – 以另一个用户的身份来执行命令

chown – Change a file’s owner

chown – 更改文件所有者

chgrp – Change a file’s group ownership

chgrp – 更改文件组所有权

passwd – Change a user’s password

passwd – 更改用户密码

```
## 拥有者、组成员和其他人
在 Unix 安全模型中，一个用户可能拥有文件和目录。当一个用户拥有一个文件或目录时， 用户对这个文件或目录的访问权限拥有控制权。用户反过来又属于一个由一个或多个 用户组成的用户组，用户组成员由文件和目录的所有者授予对文件和目录的访问权限。除了 对一个用户组授予权限之外，文件所有者可能会给所有的人授权，在 Unix 术语中，”所有的人“ 也被称作“整个世界”（ world ）。可以用 id 命令，来找到关于你自己身份的信息：
```
$ id
uid=500(me) gid=500(me) groups=500(me)
```
当用户创建帐户之后，系统会给用户分配一个号码，叫做用户 ID 或者 uid，然后，为了符合人类的习惯，这个 ID 映射到一个用户名。系统又会给这个用户 分配一个原始的组 ID(即 gid)。一个用户可以属于多个组。  

那么这些信息存在哪里呢？像 Linux 系统中的许多东西一样，存到了一系列的文本文件。用户帐户 定义在 /etc/passwd 文件里面，用户组定义在 /etc/group 文件里面。当用户帐户和用户组创建以后， 这些文件随着文件 /etc/shadow 的变动而修改，文件 /etc/shadow 包含了关于用户密码的信息。 对于每个用户帐号，文件 /etc/passwd 定义了用户（登录）名、uid、gid、帐号的真实姓名、家目录 和登录 shell。如果你查看一下文件 /etc/passwd 和文件 /etc/group 的内容，你会注意到除了普通 用户帐号之外，还有超级用户（uid 0）帐号，和各种各样的系统用户。

## 读取、写入和执行
对于文件和目录的访问权力是根据”读权限“、”写权限“和“执行权限“来定义的。   
如果我们看一下 ls 命令的输出结果，我们能得到一些线索，这是怎样实现的：
```
$ > foo.txt
$ ls -l foo.txt
-rw-rw-r-- 1 me   me   0 2008-03-06 14:52 foo.txt
```

### 文件类型
|属性	|文件类型|
|----|----|
|-	|一个普通文件|
|d	|一个目录|
|l	|一个符号链接。注意对于符号链接文件，剩余的文件属性总是"rwxrwxrwx"，而且都是 虚拟值。真正的文件属性是指符号链接所指向的文件的属性。|
|c	|一个字符设备文件。这种文件类型是指按照字节流来处理数据的设备。 比如说终端机或者调制解调器。|
|b	|一个块设备文件。这种文件类型是指按照数据块来处理数据的设备，例如一个硬盘或者 CD-ROM 盘。|

剩下的九个字符叫做文件模式，代表着文件所有者、文件组所有者和其他人的读、写和执行权限。  
当设置文件模式后，r、w和x 模式属性对文件和目录会产生以下影响：
### 权限属性
|属性|	文件|	目录|
|----|----|----|
|r|	允许打开并读取文件内容。	|允许列出目录中的内容，前提是目录必须设置了可执行属性（x）。|
|w|	允许写入文件内容或截断文件。但是不允许对文件进行重命名或删除，重命名或删除是由目录的属性决定的。|	允许在目录下新建、删除或重命名文件，前提是目录必须设置了可执行属性（x）。|
|x|	允许将文件作为程序来执行，使用脚本语言编写的程序必须设置为可读才能被执行。|	允许进入目录，例如：cd directory 。|

### 权限属性示例
|文件属性	 |   含义|
|----|----|
|-rwx------	|一个普通文件，对文件所有者来说可读、可写、可执行。其他人无法访问。|
|-rw-------	|一个普通文件，对文件所有者来说可读可写。其他人无法访问。|
|-rw-r--r--	|一个普通文件，对文件所有者来说可读可写，文件所有者的组成员可以读该文件，其他所有人都可以读该文件。|
|-rwxr-xr-x	|一个普通文件，对文件所有者来说可读、可写、可执行。也可以被其他的所有人读取和执行。|
|-rw-rw----	|一个普通文件，对文件所有者以及文件所有者的组成员来说可读可写。|
|lrwxrwxrwx	|一个符号链接，符号链接的权限都是虚拟的，真实的权限应该以符号链接指向的文件为准。|
|drwxrwx---	|一个目录，文件所有者以及文件所有者的组成员可以访问该目录，并且可以在该目录下新建、重命名、删除文件。|
|drwxr-x---	|一个目录，文件所有者可以访问该目录，并且可以在该目录下新建、重命名、删除文件，文件所有者的组成员可以访问该目录，但是不能新建、重命名、删除文件。|

## chmod － 更改文件模式
更改文件或目录的模式（权限），可以利用 chmod 命令。注意只有文件的所有者或者超级用户才 能更改文件或目录的模式。chmod 命令支持两种不同的方法来改变文件模式：八进制数字表示法或符号表示法。  
|Octal|Binary|File Mode|
|----|----|----|
|0|	000	|---|
|1|	001	|--x|
|2|	010	|-w-|
|3|	011	|-wx|
|4|	100	|r--|
|5|	101	|r-x|
|6|	110	|rw-|
|7|	111	|rwx|
通过使用3个八进制数字，我们能够设置文件所有者、用户组和其他人的权限：
```
$ > foo.txt
$ ls -l foo.txt
-rw-rw-r-- 1 me    me    0  2008-03-06 14:52 foo.txt
$ chmod 600 foo.txt
$ ls -l foo.txt
-rw------- 1 me    me    0  2008-03-06 14:52 foo.txt
```
通过传递参数 “600”，我们能够设置文件所有者的权限为读写权限，而删除用户组和其他人的所有 权限。虽然八进制到二进制的映射看起来不方便，但通常只会用到一些常见的映射关系： 7 (rwx)，6 (rw-)，5 (r-x)，4 (r--)，和 0 (---)。  

chmod 命令支持一种符号表示法，来指定文件模式。符号表示法分为三部分：更改会影响谁，要执行哪个操作，要设置哪种权限。通过字符 “u”、“g”、“o”和 “a” 的组合来指定要影响的对象。
### chmod 命令符号表示法
|符号|含义|
|----|----|
|u|	"user"的简写，意思是文件或目录的所有者。|
|g|	用户组。|
|o|	"others"的简写，意思是其他所有的人。|
|a|	"all"的简写，是"u", "g"和“o”三者的联合。|

如果没有指定字符，则假定使用”all”。执行的操作可能是一个“＋”字符，表示加上一个权限， 一个“－”，表示删掉一个权限，或者是一个“＝”，表示只有指定的权限可用，其它所有的权限被删除。  


权限由 “r”、“w”和 “x” 来指定。这里是一些符号表示法的实例：
### chmod 符号表示法实例
|符号|含义|
|----|----|
|u+x	    |为文件所有者添加可执行权限。|
|u-x	    |删除文件所有者的可执行权限。|
|+x	        |为文件所有者，用户组，和其他所有人添加可执行权限。 等价于 a+x。|
|o-rw	    |除了文件所有者和用户组，删除其他人的读权限和写权限。|
|go=rw	    |给文件所属的组和文件所属者组以外的人读写权限。如果文件所属组或其他人已经拥有执行的权限，执行权限将被移除。|
|u+x,go=rw	|给文件拥有者执行权限并给组和其他人读和执行的权限。多种设定可以用逗号分开。|

## umask － 设置默认权限
当创建一个文件时，umask 命令控制着文件的默认权限。umask 命令使用八进制表示法来表达从文件模式属性中删除一个位掩码。

## 更改身份
很多时候，我们会发现很有必要使用另一个用户的身份来执行一些操作。经常地，我们想要得到超级 用户特权，来执行一些管理任务，但是也有可能”变为”另一个普通用户，比如说测试一个帐号。 有三种方式，可以拥有多重身份：  
1.注销系统并以其他用户身份重新登录系统。  
2.使用 su 命令。  
3.使用 sudo 命令。  

在我们自己的 shell 会话中，su 命令允许你假定为另一个用户的身份，以这个用户的 ID 启动一个新的 shell 会话，或者是以这个用户的身份来发布一个命令。  
sudo 命令允许一个管理员 设置一个叫做 /etc/sudoers 的配置文件，并且定义了一些具体命令，允许变身用户执行这些命令。选择使用哪个命令，很大程度上是由你使用的 Linux 发行版来决定的。你的发行版可能这两个命令都包含，但系统配置可能会禁用其中一个。

### su － 以其他用户身份和组 ID 运行一个 shell
su 命令用来以另一个用户的身份来启动 shell。这个命令语法看起来像这样：
```
su [-[l]] [user]
```
如果包含”-l”选项，那么会为指定用户启动一个需要登录的 shell。这意味着会加载此用户的 shell 环境， 并且工作目录会更改到这个用户的家目录。这通常是我们所需要的。如果不指定用户，那么就假定是超级用户。注意，选项”-l”可以缩写为”-“，这是经常用到的形式。启动超级用户的 shell， 我们可以这样做：
```
$ su -
Password:
#
```
按下回车符之后，shell 提示我们输入超级用户的密码。如果密码输入正确，出现一个新的 shell 提示符， 这表明这个 shell 具有超级用户特权（提示符的末尾字符是”#”而不是”$”），并且当前工作目录是超级用户的家目录（通常是/root）。一旦进入一个新的 shell，我们能执行超级用户所使用的命令。当工作完成后， 输入”exit”，则返回到原来的 shell:  

以这样的方式使用 su 命令，也可以只执行单个命令，而不是启动一个新的可交互的 shell：
```
su -c 'command'
```
使用这种模式，命令传递到一个新 shell 中执行。把命令用单引号引起来很重要，因为我们不想命令在我们的 shell 中展开，但需要在新 shell 中展开。
```
$ su -c 'ls -l /root/*'
Password:
-rw------- 1 root root    754 2007-08-11 03:19 /root/anaconda-ks.cfg

/root/Mail:
total 0
$
```

### sudo － 以另一个用户身份执行命令
sudo 命令在很多方面都相似于 su 命令，但是 sudo 还有一些非常重要的功能。管理员能够配置 sudo 命令，从而允许一个普通用户以不同的身份（通常是超级用户），通过一种非常可控的方式来执行命令。尤其是，只有一个用户可以执行一个或多个特殊命令时，（更体现了 sudo 命令的方便性）。 另一个重要差异是 sudo 命令不要求超级用户的密码。使用 sudo 命令时，用户使用他/她自己的密码来认证。比如说，例如，sudo 命令经过配置，允许我们运行一个虚构的备份程序，叫做”backup_script”， 这个程序要求超级用户权限。通过 sudo 命令，这个程序会像这样运行：
```
$ sudo backup_script
Password:
System Backup Starting...
```
按下回车键之后，shell 提示我们输入我们的密码（不是超级用户的）。一旦认证完成，则执行 具体的命令。su 和 sudo 之间的一个重要区别是 sudo 不会重新启动一个 shell，也不会加载另一个 用户的 shell 运行环境。这意味者命令不必用单引号引起来。想知道 sudo 命令可以授予哪些权限，使用”-l”选项，列出所有权限

## chown － 更改文件所有者和用户组
chown 命令被用来更改文件或目录的所有者和用户组。使用这个命令需要超级用户权限。chown 命令 的语法看起来像这样：
```
chown [owner][:[group]] file...
```
chown 可以根据这个命令的第一个参数更改文件所有者和/或文件用户组。这里有 一些例子：
### chown 参数实例
|参数	    | 结果|
|----|----|
|bob	    |把文件所有者从当前属主更改为用户 bob。|
|bob:users	|把文件所有者改为用户 bob，文件用户组改为用户组 users。|
|:admins	|把文件用户组改为组 admins，文件所有者不变。|
|bob:	    |文件所有者改为用户 bob，文件用户组改为用户 bob 登录系统时所属的用户组。|

## chgrp － 更改用户组所有权
在旧版 Unix 系统中，chown 命令只能更改文件所有权，而不是用户组所有权。为了达到目的， 使用一个独立的命令，chgrp 来完成。除了限制多一点之外，chgrp 命令与 chown 命令使用起来很相似。

## 更改用户密码
使用 passwd 命令，来设置或更改用户密码。命令语法如下所示：
```
passwd [user]
```
只要输入 passwd 命令，就能更改你的密码。shell 会提示你输入你的旧密码和你的新密码：
```
$ passwd
(current) UNIX password:
New UNIX password:
```
passwd 命令将会试着强迫你使用“强”密码。这意味着它会拒绝接受太短的密码、与先前相似的密码、字典中的单词作为密码或者是太容易猜到的密码：
```
$ passwd
(current) UNIX password:
New UNIX password:
BAD PASSWORD: is too similar to the old one
New UNIX password:
BAD PASSWORD: it is WAY too short
New UNIX password:
BAD PASSWORD: it is based on a dictionary word
```
如果你具有超级用户权限，你可以指定一个用户名作为 passwd 命令的参数，这样可以设置另一个用户的密码。还有其它的 passwd 命令选项对超级用户有效，允许帐号锁定，密码失效，等等。 


# 11.进程
```
ps– Report a snapshot of current processes

top – Display tasks

jobs – List active jobs

bg – Place a job in the background

fg – Place a job in the foreground

kill – Send a signal to a process

killall – Kill processes by name

shutdown – Shutdown or reboot the system

ps – 报告当前进程快照

top – 显示任务

jobs – 列出活跃的任务

bg – 把一个任务放到后台执行

fg – 把一个任务放到前台执行

kill – 给一个进程发送信号

killall – 杀死指定名字的进程

shutdown – 关机或重启系统
```

## 进程是怎样工作的

当系统启动的时候，内核先把一些它自己的活动初始化为进程，然后运行一个叫做 init 的程序。init， 依次地，再运行一系列的称为 init 脚本的 shell 脚本（位于 /etc ），它们可以启动所有的系统服务。 其中许多系统服务以守护进程（daemon）的形式实现，守护进程仅在后台运行，没有任何用户接口(User Interface)。即使我们没有登录系统，系统也在执行一些例行事务。  

从进程的角度而言，一个程序启动另一个程序可以被表述为一个父进程可以产生一个子进程。  

内核维护每个进程的信息，以此来保持事情有序。例如，系统分配给每个进程一个数字，这个数字叫做 进程(process) ID 即 PID。PID 号按升序分配，init 进程的 PID 总是1。内核也对分配给每个进程的内存和就绪状态进行跟踪以便继续执行这个进程。像文件一样，进程也有所有者和用户 ID，有效用户 ID，等等。

## 查看进程
查看进程，最常使用地命令（有几个命令）是 ps(process status)。ps 程序有许多选项，它最简单地使用形式是这样的：
```
$ ps
PID TTY           TIME CMD
5198 pts/1    00:00:00 bash
10129 pts/1   00:00:00 ps
```

```
$ ps aux
USER   PID  %CPU  %MEM     VSZ    RSS  TTY   STAT   START   TIME  COMMAND
root     1   0.0   0.0    2136    644  ?     Ss     Mar05   0:31  init
root     2   0.0   0.0       0      0  ?     S&lt;     Mar05   0:00  [kt]
``` 
这个选项组合，能够显示属于每个用户的进程信息。使用这个选项，可以唤醒 “BSD 风格” 的输出结果。 Linux 版本的 ps 命令，可以模拟几个不同 Unix 版本中的 ps 程序的行为。通过这些选项，我们得到 这些额外的列。

## 进程状态
|状态|	含义|
|----|----|
|R|	运行中。这意味着，进程正在运行或准备运行。|
|S|	正在睡眠。进程没有运行，而是，正在等待一个事件， 比如说，一个按键或者网络分组。|
|D|	不可中断睡眠。进程正在等待 I/O，比方说，一个磁盘驱动器的 I/O。|
|T|	已停止. 已经指示进程停止运行。稍后介绍更多。|
|Z|	一个死进程或“僵尸”进程。这是一个已经终止的子进程，但是它的父进程还没有清空它。 （父进程没有把子进程从进程表中删除）|
|<|	一个高优先级进程。这可能会授予一个进程更多重要的资源，给它更多的 CPU 时间。 进程的这种属性叫做 niceness。具有高优先级的进程据说是不好的（less nice）， 因为它占用了比较多的 CPU 时间，这样就给其它进程留下很少时间。|
|N|	低优先级进程。 一个低优先级进程，只有当其它高优先级进程被服务了之后，才会得到处理器时间。|

## 用 top 命令动态查看进程
虽然 ps 命令能够展示许多计算机运行状态的信息，但是它只是提供 ps 命令执行时刻的机器状态快照。 为了看到更多动态的信息，我们使用 top 命令：
```
$ top
```
top 程序以进程活动顺序显示连续更新的系统进程列表。（默认情况下，每三秒钟更新一次），”top”这个名字 来源于 top 程序是用来查看系统中“顶端”进程的。top 显示结果由两部分组成： 最上面是系统概要，下面是进程列表，以 CPU 的使用率排序。

## 通过 kill 命令给进程发送信号
kill 命令被用来给程序发送信号。它最常见的语法形式看起来像这样：
```
kill [-signal] PID...
```
如果在命令行中没有指定信号，那么默认情况下，发送 TERM（Terminate，终止）信号。kill 命令被经常 用来发送以下命令：

###  常用信号
|编号|	名字|	含义|
|----|----|----|
|1|	HUP	|挂起（Hangup）。名字来源于很久以前，那时候终端机通过电话线和调制解调器连接到 远端的计算机。这个信号被用来告诉程序，控制的终端机已经“挂断”。 通过关闭一个终端会话，可以展示这个信号的作用。在当前终端运行的前台程序将会收到这个信号并终止。许多守护进程也使用这个信号，来重新初始化。这意味着，当一个守护进程收到这个信号后， 这个进程会重新启动，并且重新读取它的配置文件。Apache 网络服务器守护进程就是一个例子。|
|2	|INT	|中断。实现和 Ctrl-c 一样的功能，由终端发送。通常，它会终止一个程序。|
|9	|KILL	|杀死。这个信号很特别。尽管程序可能会选择不同的方式来处理发送给它的 信号，其中也包含忽略信号，但是 KILL 信号从不被发送到目标程序。而是内核立即终止 这个进程。当一个进程以这种方式终止的时候，它没有机会去做些“清理”工作，或者是保存工作。 因为这个原因，把 KILL 信号看作最后一招，当其它终止信号失败后，再使用它。|
|15|	TERM|	终止。这是 kill 命令发送的默认信号。如果程序仍然“活着”，可以接受信号，那么 这个它会终止。|
|18	|CONT	|继续。在一个停止信号后，这个信号会恢复进程的运行。|
|19	|STOP	|停止。这个信号导致进程停止运行，而不是终止。像 KILL 信号，它不被 发送到目标进程，因此它不能被忽略。|

通过 killall 命令给多个进程发送信号，给匹配特定程序或用户名的多个进程发送信号。下面是 killall 命令的语法形式：
```
killall [-u user] [-signal] name...
```

# shell 环境
```
printenv - 打印部分或所有的环境变量

set - 设置 shell 选项

export — 导出环境变量，让随后执行的程序知道。

alias - 创建命令别名
```
shell 在环境中存储了两种基本类型的数据，虽然在 bash 里，我们几乎无法区分它们。 它们是环境变量和 shell 变量。Shell 变量是 bash 存放的少量数据。剩下的都是 环境变量。除了变量，shell 也存储了一些可编程的数据，即别名和 shell 函数。

## 检查环境变量

我们可以用 bash 的内建命令 set，或者是 printenv 程序来查看环境变量。set 命令可以 显示 shell 或环境变量，而 printenv 只是显示环境变量。因为环境变量列表比较长，最好 把每个命令的输出通过管道传递给 less 来阅读：
```
$ printenv | less
```

当使用没有带选项和参数的 set 命令时，shell 变量，环境变量，和定义的 shell 函数 都会被显示。不同于 printenv 命令，set 命令的输出很友好地按照首字母顺序排列：
```
$ set | less
```

## 使用文本编辑器
所有的文本编辑器都可以通过在命令行中输入编辑器的名字，加上你所想要编辑的文件来唤醒。如果所 输入的文件名不存在，编辑器则会假定你想要创建一个新文件。下面是一个使用 gedit 的例子：
```
$ gedit some_file
```
这条命令将会启动 gedit 文本编辑器，同时加载名为 “some_file” 的文件，如果这个文件存在的话。

## 激活我们的修改
我们对于文件 .bashrc 的修改不会生效，直到我们关闭终端会话，再重新启动一个新的会话， 因为 .bashrc 文件只是在刚开始启动终端会话时读取。然而，我们可以强迫 bash 重新读取修改过的 .bashrc 文件，使用下面的命令：
```
$ source .bashrc
```

# vi简介
## 启动和退出 vi

要想启动 vi，只要简单地输入以下命令：
```
$ vi
```
要退出 vi，输入下面的命令（注意冒号是命令的一部分）：
```
:q
```
shell 提示符应该重新出现。如果由于某种原因，vi 不能退出（通常因为我们对文件做了修改，却没有保存文件）。 通过给命令加上叹号，我们可以告诉 vi 我们真要退出 vi。（注意感叹号是命令的一部分）
```
:q!
```

## 插入模式

为了在文件中添加文本，我们需要先进入插入模式。按下”i”键进入插入模式。  
若要退出插入模式返回命令模式，按下 Esc 按键。  

## 保存我们的工作
为了保存我们刚才对文件所做的修改，我们必须在命令模式下输入一个 ex 命令。通过按下”:”键。  
为了写入我们修改的文件，我们在冒号之后输入”w”字符，然后按下回车键。  


# 软件包管理
## 查找包仓库中的软件包
使用上层工具来搜索包仓库元数据，可以根据软件包的名字和说明来定位它。
|风格 |	命令|
|Debian	|apt-get update; apt-cache search search_string|
|Red Hat|	yum search search_string|
例如：搜索一个 yum 包仓库来查找 emacs 文本编辑器，使用以下命令：
```
yum search emacs
```

## 从包仓库中安装一个软件包
上层工具允许从一个资、包仓库中下载一个软件包，并经过完全依赖解析来安装它。
|风格 |	命令|
|----|----|
|Debian	|apt-get update; apt-get install package_name|
|Red Hat|	yum install package_name|

例如：从一个 apt 包仓库来安装 emacs 文本编辑器：
```
apt-get update; apt-get install emacs
```

## 通过软件包文件来安装软件
如果从某处而不是从包仓库中下载了一个软件包文件，可以使用底层工具来直接（不经过依赖解析）安装它。  
|风格 |	命令|
|----|----|
|Debian	|dpkg --install package_file|
|Red Hat|	rpm -i package_file|

例如：如果已经从一个并非包仓库的网站下载了软件包文件 emacs-22.1-7.fc7-i386.rpm， 则可以通过这种方法来安装它：
```
rpm -i emacs-22.1-7.fc7-i386.rpm
```
注意：因为这项技术使用底层的 rpm 程序来执行安装任务，所以没有运行依赖解析。 如果 rpm 程序发现缺少了一个依赖，则会报错并退出。

## 卸载软件
可以使用上层或者底层工具来卸载软件。下面是可用的上层工具。
|风格 |	命令|
|----|----|
|Debian	|apt-get remove package_name|
|Red Hat|yum erase package_name|    

例如：从 Debian 风格的系统中卸载 emacs 软件包：
```
apt-get remove emacs
```
## 经过包仓库来更新软件包
最常见的软件包管理任务是保持系统中的软件包都是最新的。上层工具仅需一步就能完成 这个至关重要的任务。
|风格 |	命令|
|----|----|
|Debian	|apt-get update; apt-get upgrade|
|Red Hat|	yum update|

例如：更新安装在 Debian 风格系统中的软件包：
```
apt-get update; apt-get upgrade
```

## 经过软件包文件来升级软件
如果已经从一个非包仓库网站下载了一个软件包的最新版本，可以安装这个版本，用它来 替代先前的版本：
|风格 |	命令|
|----|----|
|Debian	 | dpkg --install package_file|
|Red Hat | 	rpm -U package_file|

例如：把 Red Hat 系统中所安装的 emacs 的版本更新到软件包文件 emacs-22.1-7.fc7-i386.rpmz 所包含的 emacs 版本。
```
rpm -U emacs-22.1-7.fc7-i386.rpm
```
注意：rpm 程序安装一个软件包和升级一个软件包所用的选项是不同的，而 dpkg 程序所用的选项是相同的。

## 列出所安装的软件包
下表中的命令可以用来显示安装到系统中的所有软件包列表：

|风格 |	命令|
|----|----|
|Debian	|dpkg --list|
|Red Hat|	rpm -qa|


## 确定是否安装了一个软件包
这些底端工具可以用来显示是否安装了一个指定的软件包：

|风格 |	命令|
|----|----|
|Debian	|dpkg --status package_name|
|Red Hat|	rpm -q package_name|

例如：确定是否 Debian 风格的系统中安装了这个 emacs 软件包：
```
dpkg --status emacs
```

## 显示所安装软件包的信息
如果知道了所安装软件包的名字，使用以下命令可以显示这个软件包的说明信息：
|风格 |	命令|
|----|----|
|Debian	|apt-cache show package_name|
|Red Hat|	yum info package_name|

例如：查看 Debian 风格的系统中 emacs 软件包的说明信息：
```
apt-cache show emacs
```

## 查找安装了某个文件的软件包
确定哪个软件包对所安装的某个特殊文件负责，使用下表中的命令：
|风格 |	命令|
|----|----|
|Debian	|dpkg --search file_name|
|Red Hat|	rpm -qf file_name|

例如：在 Red Hat 系统中，查看哪个软件包安装了/usr/bin/vim 这个文件
```
rpm -qf /usr/bin/vim
```

# 网络系统
```
ping - 发送 ICMP ECHO_REQUEST 数据包到网络主机

traceroute - 打印到一台网络主机的路由数据包

netstat - 打印网络连接，路由表，接口统计数据，伪装连接，和多路广播成员

ftp - 因特网文件传输程序

wget - 非交互式网络下载器

ssh - OpenSSH SSH 客户端（远程登录程序）
```

## 检查和监测网络
### ping
最基本的网络命令是 ping。这个 ping 命令发送一个特殊的网络数据包，叫做 ICMP ECHO_REQUEST，到 一台指定的主机。大多数接收这个包的网络设备将会回复它，来允许网络连接验证。  
```
$ ping linuxcommand.org
```
注意：大多数网络设备（包括 Linux 主机）都可以被配置为忽略这些数据包。通常，这样做是出于网络安全 原因，部分地遮蔽一台主机免受一个潜在攻击者地侵袭。配置防火墙来阻塞 IMCP 流量也很普遍。  

### traceroute
这个 traceroute 程序（一些系统使用相似的 tracepath 程序来代替）会显示从本地到指定主机 要经过的所有“跳数”的网络流量列表。例如，看一下到达 slashdot.org 需要经过的路由， 我们将这样做：
```
$ traceroute slashdot.org
```

### netstat
netstat 程序被用来检查各种各样的网络设置和统计数据。通过此命令的许多选项，我们 可以看看网络设置中的各种特性。使用“-ie”选项，我们能够查看系统中的网络接口：
```
$ netstat -ie
```

## 网络中传输文件
如果不能通过网络来传输文件，那么要网络有什么用呢？有许多程序可以用来在网络中 传送数据。我们先讨论两个，随后的章节里再介绍几个。

### ftp
ftp 命令属于真正的“经典”程序之一，它的名字来源于其所使用的协议，就是文件传输协议。 FTP 被广泛地用来从因特网上下载文件。大多数，并不是所有的，网络浏览器都支持 FTP， 你经常可以看到它们的 URI 以协议 ftp://开头。在出现网络浏览器之前，ftp 程序已经存在了。 ftp 程序可用来与 FTP 服务器进行通信，FTP 服务器就是存储文件的计算机，这些文件能够通过 网络下载和上传。  

FTP（它的原始版本）并不是安全的，因为它会以明码形式发送帐号的姓名和密码。这就意味着 这些数据没有加密，任何嗅探网络的人都能看到。由于此种原因，几乎因特网中所有 FTP 服务器 都是匿名的。一个匿名服务器能允许任何人使用注册名“anonymous”和无意义的密码登录系统。  

### lftp - 更好的 ftp
ftp 并不是唯一的命令行形式的 FTP 客户端。实际上，还有很多。其中比较好（也更流行的）是 lftp 程序， 由 Alexander Lukyanov 编写完成。虽然 lftp 工作起来与传统的 ftp 程序很相似，但是它带有额外的便捷特性，包括 多协议支持（包括 HTTP），若下载失败会自动地重新下载，后台处理，用 tab 按键来补全路径名，还有很多。

### wget

另一个流行的用来下载文件的命令行程序是 wget。若想从网络和 FTP 网站两者上都能下载数据，wget 是很有用处的。 不只能下载单个文件，多个文件，甚至整个网站都能下载。

## 与远程主机安全通信
通过网络来远程操控类 Unix 的操作系统已经有很多年了。早些年，在因特网普遍推广之前，有 一些受欢迎的程序被用来登录远程主机。它们是 rlogin 和 telnet 程序。然而这些程序，拥有和 ftp 程序 一样的致命缺点；它们以明码形式来传输所有的交流信息（包括登录命令和密码）。这使它们完全不 适合使用在因特网时代。

### ssh
为了解决这个问题，开发了一款新的协议，叫做 SSH（Secure Shell）。 SSH 解决了这两个基本的和远端主机安全交流的问题。首先，它要认证远端主机是否为它 所知道的那台主机（这样就阻止了所谓的“中间人”的攻击），其次，它加密了本地与远程主机之间 所有的通讯信息。  

SSH 由两部分组成。SSH 服务端运行在远端主机上，在端口 22 上监听收到的外部连接，而 SSH 客户端用在本地系统中，用来和远端服务器通信。  

大多数 Linux 发行版自带一个提供 SSH 功能的软件包，叫做 OpenSSH，来自于 BSD 项目。一些发行版 默认包含客户端和服务端两个软件包（例如 Red Hat），而另一些（比方说 Ubuntu）则只提供客户端。 为了能让系统接受远端的连接，它必须安装 OpenSSH-server 软件包，配置，运行它， 并且（如果系统正在运行，或者系统在防火墙之后）它必须允许在 TCP 端口 22 上接收网络连接。  

小贴示：如果你没有远端系统去连接，但还想试试这些实例，则确认安装了 OpenSSH-server 软件包 ，则可使用 localhost 作为远端主机的名字。这种情况下，计算机会和它自己创建网络连接。  

## SSH 通道

当你通过 SSH 协议与远端主机建立连接的时候，其中发生的事就是在本地与远端系统之间 创建了一条加密通道。通常，这条通道被用来把在本地系统中输入的命令安全地传输到远端系统，同样地，再把执行结果安全地发送回来。除了这个基本功能之外，SSH 协议允许大多数网络流量类型通过这条加密通道来被传送，在本地与远端系统之间创建一种 VPN（虚拟专用网络）。  

### scp 和 sftp
OpenSSH 软件包也包含两个程序，它们可以利用 SSH 加密通道在网络间复制文件。 第一个，scp（安全复制）被用来复制文件，与熟悉的 cp 程序非常相似。最显著的区别就是 源或者目标路径名要以远端主机的名字，后跟一个冒号字符开头。  

第二个 SSH 文件复制程序是 sftp，顾名思义，它是 ftp 程序的安全替代品。sftp 工作起来与我们 之前使用的 ftp 程序很相似；然而，它不用明码形式来传递数据，它使用加密的 SSH 通道。sftp 有一个 重要特性强于传统的 ftp 命令，就是 sftp 不需要远端系统中运行 FTP 服务端。它仅仅需要 SSH 服务端。 这意味着任何一台能用 SSH 客户端连接的远端机器，也可当作类似于 FTP 的服务器来使用。  

